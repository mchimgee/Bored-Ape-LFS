'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var HDKey = _interopDefault(require('hdkey'));
var ethereumjsUtil = require('ethereumjs-util');
var tx = require('@ethereumjs/tx');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');

const keyringType = 'QR Hardware Wallet Device';
const pathBase = 'm';
const MAX_INDEX = 1000;
class BaseKeyring {
  constructor(opts) {
    this.getInteraction = () => {
      throw new Error('#ktek_error, method getInteraction not implemented, please extend BaseKeyring by overwriting this method.');
    };

    this.type = keyringType;

    this.readKeyringCryptoHDKey = async () => {
      var _cryptoHDKey$getOrigi;

      const cryptoHDKey = await this.getInteraction().readCryptoHDKey();
      const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;
      const xfp = (_cryptoHDKey$getOrigi = cryptoHDKey.getOrigin().getSourceFingerprint()) == null ? void 0 : _cryptoHDKey$getOrigi.toString('hex');

      if (!xfp) {
        throw new Error('invalid crypto-hd-key, cannot get source fingerprint');
      }

      const xpub = cryptoHDKey.getBip32Key();
      return {
        xfp,
        xpub,
        hdPath
      };
    };

    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {
      const ethSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);
      const requestIdBuffer = ethSignature.getRequestId();
      const signature = ethSignature.getSignature();

      if (requestIdBuffer) {
        const requestId = uuid.stringify(requestIdBuffer);

        if (requestId !== _requestId) {
          throw new Error('read signature error: mismatched requestId');
        }
      }

      const r = signature.slice(0, 32);
      const s = signature.slice(32, 64);
      const v = signature.slice(64);
      return {
        r,
        s,
        v
      };
    };

    this.xfp = '';
    this.xpub = '';
    this.hdPath = '';
    this.page = 0;
    this.perPage = 5;
    this.accounts = [];
    this.currentAccount = 0;
    this.paths = {};
    this.latestAccount = 0;
    this.deserialize(opts);
  }

  async readKeyring() {
    const {
      xpub,
      xfp,
      hdPath
    } = await this.readKeyringCryptoHDKey();
    this.xfp = xfp;
    this.xpub = xpub;
    this.hdPath = hdPath;
  }

  checkKeyring() {
    if (!this.xfp || !this.xpub || !this.hdPath) {
      throw new Error('keyring not fulfilled, please call function `readKeyring` firstly');
    }
  }

  serialize() {
    return Promise.resolve({
      xfp: this.xfp,
      xpub: this.xpub,
      hdPath: this.hdPath,
      accounts: this.accounts,
      currentAccount: this.currentAccount,
      page: this.page,
      perPage: this.perPage,
      paths: this.paths
    });
  }

  deserialize(opts) {
    if (opts) {
      this.xfp = opts.xfp;
      this.xpub = opts.xpub;
      this.hdPath = opts.hdPath;
      this.accounts = opts.accounts;
      this.currentAccount = opts.currentAccount;
      this.page = opts.page;
      this.perPage = opts.perPage;
      this.paths = opts.paths;
    }
  }

  setCurrentAccount(index) {
    this.currentAccount = index;
  }

  getCurrentAccount() {
    return this.currentAccount;
  }

  getCurrentAddress() {
    return this.accounts[this.currentAccount];
  }

  addAccounts(n = 1) {
    return new Promise((resolve, reject) => {
      try {
        const from = this.latestAccount;
        const to = from + n;
        const newAccounts = [];

        for (let i = from; i < to; i++) {
          const address = this._addressFromIndex(pathBase, i);

          newAccounts.push(address);
          this.page = 0;
          this.latestAccount++;
        }

        this.accounts = this.accounts.concat(newAccounts);
        resolve(this.accounts);
      } catch (e) {
        reject(e);
      }
    });
  }

  getFirstPage() {
    this.page = 0;
    return this.__getPage(1);
  }

  getNextPage() {
    return this.__getPage(1);
  }

  getPreviousPage() {
    return this.__getPage(-1);
  }

  async __getPage(increment) {
    this.page += increment;

    if (this.page <= 0) {
      this.page = 1;
    }

    if (!!!this.xfp) {
      await this.readKeyring();
    }

    return new Promise((resolve, reject) => {
      try {
        const from = (this.page - 1) * this.perPage;
        const to = from + this.perPage;
        const accounts = [];

        for (let i = from; i < to; i++) {
          const address = this._addressFromIndex(pathBase, i);

          accounts.push({
            address,
            balance: null,
            index: i
          });
          this.paths[ethereumjsUtil.toChecksumAddress(address)] = i;
        }

        resolve(accounts);
      } catch (e) {
        reject(e);
      }
    });
  }

  getAccounts() {
    return Promise.resolve(this.accounts);
  }

  removeAccount(address) {
    if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
  } // tx is an instance of the ethereumjs-transaction class.


  static serializeTx(tx) {
    // need use EIP-155
    // @ts-ignore
    tx.v = new ethereumjsUtil.BN(tx.common.chainId()); // @ts-ignore

    tx.r = new ethereumjsUtil.BN(0); // @ts-ignore

    tx.s = new ethereumjsUtil.BN(0);
    return tx.serialize();
  }

  async signTransaction(address, tx$1) {
    const hdPath = this._pathFromAddress(address);

    const chainId = tx$1.common.chainId();
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(BaseKeyring.serializeTx(tx$1), bcUrRegistryEth.DataType.transaction, hdPath, this.xfp, requestId, chainId);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    const txJson = tx$1.toJSON();
    return tx.Transaction.fromTxData({
      to: txJson['to'],
      gasLimit: txJson['gasLimit'],
      gasPrice: txJson['gasPrice'],
      data: txJson['data'],
      nonce: txJson['nonce'],
      value: txJson['value'],
      r,
      s,
      v
    }, {
      common: tx$1.common
    });
  }

  signMessage(withAccount, data) {
    return this.signPersonalMessage(withAccount, data);
  }

  async signPersonalMessage(withAccount, messageHex) {
    const usignedHex = ethereumjsUtil.stripHexPrefix(messageHex);

    const hdPath = this._pathFromAddress(withAccount);

    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(usignedHex, 'hex'), bcUrRegistryEth.DataType.personalMessage, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');
    return '0x' + Buffer.concat([r, s, v]).toString('hex');
  }

  async signTypedData(withAccount, typedData) {
    const hdPath = this._pathFromAddress(withAccount);

    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(typedData), 'utf-8'), bcUrRegistryEth.DataType.typedData, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, 'Scan with your Keystone', 'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');
    return '0x' + Buffer.concat([r, s, v]).toString('hex');
  }

  _addressFromIndex(pb, i) {
    this.checkKeyring();

    if (!this.hdk) {
      // @ts-ignore
      this.hdk = HDKey.fromExtendedKey(this.xpub);
    }

    const dkey = this.hdk.derive(`${pb}/0/${i}`);
    const address = '0x' + ethereumjsUtil.publicToAddress(dkey.publicKey, true).toString('hex');
    return ethereumjsUtil.toChecksumAddress(address);
  }

  _pathFromAddress(address) {
    const checksummedAddress = ethereumjsUtil.toChecksumAddress(address);
    let index = this.paths[checksummedAddress];

    if (typeof index === 'undefined') {
      for (let i = 0; i < MAX_INDEX; i++) {
        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {
          index = i;
          break;
        }
      }
    }

    if (typeof index === 'undefined') {
      throw new Error('Unknown address');
    }

    return `${this.hdPath}/0/${index}`;
  }

}
BaseKeyring.type = keyringType;

exports.BaseKeyring = BaseKeyring;
//# sourceMappingURL=base-eth-keyring.cjs.development.js.map
