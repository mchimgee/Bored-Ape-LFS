"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t,e=(t=require("hdkey"))&&"object"==typeof t&&"default"in t?t.default:t,s=require("ethereumjs-util"),r=require("@ethereumjs/tx"),i=require("@keystonehq/bc-ur-registry-eth"),n=require("uuid");class a{constructor(t){this.getInteraction=()=>{throw new Error("#ktek_error, method getInteraction not implemented, please extend BaseKeyring by overwriting this method.")},this.type="QR Hardware Wallet Device",this.readKeyringCryptoHDKey=async()=>{var t;const e=await this.getInteraction().readCryptoHDKey(),s="m/"+e.getOrigin().getPath(),r=null==(t=e.getOrigin().getSourceFingerprint())?void 0:t.toString("hex");if(!r)throw new Error("invalid crypto-hd-key, cannot get source fingerprint");return{xfp:r,xpub:e.getBip32Key(),hdPath:s}},this.requestSignature=async(t,e,s,r)=>{const i=await this.getInteraction().requestSignature(e,s,r),a=i.getRequestId(),o=i.getSignature();if(a&&n.stringify(a)!==t)throw new Error("read signature error: mismatched requestId");return{r:o.slice(0,32),s:o.slice(32,64),v:o.slice(64)}},this.xfp="",this.xpub="",this.hdPath="",this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.paths={},this.latestAccount=0,this.deserialize(t)}async readKeyring(){const{xpub:t,xfp:e,hdPath:s}=await this.readKeyringCryptoHDKey();this.xfp=e,this.xpub=t,this.hdPath=s}checkKeyring(){if(!this.xfp||!this.xpub||!this.hdPath)throw new Error("keyring not fulfilled, please call function `readKeyring` firstly")}serialize(){return Promise.resolve({xfp:this.xfp,xpub:this.xpub,hdPath:this.hdPath,accounts:this.accounts,currentAccount:this.currentAccount,page:this.page,perPage:this.perPage,paths:this.paths})}deserialize(t){t&&(this.xfp=t.xfp,this.xpub=t.xpub,this.hdPath=t.hdPath,this.accounts=t.accounts,this.currentAccount=t.currentAccount,this.page=t.page,this.perPage=t.perPage,this.paths=t.paths)}setCurrentAccount(t){this.currentAccount=t}getCurrentAccount(){return this.currentAccount}getCurrentAddress(){return this.accounts[this.currentAccount]}addAccounts(t=1){return new Promise((e,s)=>{try{const s=this.latestAccount,r=s+t,i=[];for(let t=s;t<r;t++){const e=this._addressFromIndex("m",t);i.push(e),this.page=0,this.latestAccount++}this.accounts=this.accounts.concat(i),e(this.accounts)}catch(t){s(t)}})}getFirstPage(){return this.page=0,this.__getPage(1)}getNextPage(){return this.__getPage(1)}getPreviousPage(){return this.__getPage(-1)}async __getPage(t){return this.page+=t,this.page<=0&&(this.page=1),this.xfp||await this.readKeyring(),new Promise((t,e)=>{try{const e=(this.page-1)*this.perPage,r=e+this.perPage,i=[];for(let t=e;t<r;t++){const e=this._addressFromIndex("m",t);i.push({address:e,balance:null,index:t}),this.paths[s.toChecksumAddress(e)]=t}t(i)}catch(t){e(t)}})}getAccounts(){return Promise.resolve(this.accounts)}removeAccount(t){if(!this.accounts.map(t=>t.toLowerCase()).includes(t.toLowerCase()))throw new Error(`Address ${t} not found in this keyring`);this.accounts=this.accounts.filter(e=>e.toLowerCase()!==t.toLowerCase())}static serializeTx(t){return t.v=new s.BN(t.common.chainId()),t.r=new s.BN(0),t.s=new s.BN(0),t.serialize()}async signTransaction(t,e){const s=this._pathFromAddress(t),o=e.common.chainId(),h=n.v4(),c=i.EthSignRequest.constructETHRequest(a.serializeTx(e),i.DataType.transaction,s,this.xfp,h,o),{r:u,s:g,v:d}=await this.requestSignature(h,c,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature'),p=e.toJSON();return r.Transaction.fromTxData({to:p.to,gasLimit:p.gasLimit,gasPrice:p.gasPrice,data:p.data,nonce:p.nonce,value:p.value,r:u,s:g,v:d},{common:e.common})}signMessage(t,e){return this.signPersonalMessage(t,e)}async signPersonalMessage(t,e){const r=s.stripHexPrefix(e),a=this._pathFromAddress(t),o=n.v4(),h=i.EthSignRequest.constructETHRequest(Buffer.from(r,"hex"),i.DataType.personalMessage,a,this.xfp,o,void 0,t),{r:c,s:u,v:g}=await this.requestSignature(o,h,"Scan with your Keystone",'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([c,u,g]).toString("hex")}async signTypedData(t,e){const s=this._pathFromAddress(t),r=n.v4(),a=i.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(e),"utf-8"),i.DataType.typedData,s,this.xfp,r,void 0,t),{r:o,s:h,v:c}=await this.requestSignature(r,a,"Scan with your Keystone",'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([o,h,c]).toString("hex")}_addressFromIndex(t,r){this.checkKeyring(),this.hdk||(this.hdk=e.fromExtendedKey(this.xpub));const i=this.hdk.derive(`${t}/0/${r}`),n="0x"+s.publicToAddress(i.publicKey,!0).toString("hex");return s.toChecksumAddress(n)}_pathFromAddress(t){const e=s.toChecksumAddress(t);let r=this.paths[e];if(void 0===r)for(let t=0;t<1e3;t++)if(e===this._addressFromIndex("m",t)){r=t;break}if(void 0===r)throw new Error("Unknown address");return`${this.hdPath}/0/${r}`}}a.type="QR Hardware Wallet Device",exports.BaseKeyring=a;
//# sourceMappingURL=base-eth-keyring.cjs.production.min.js.map
