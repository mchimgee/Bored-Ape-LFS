"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ETHSignature = void 0;
const cbor_sync_1 = require("../lib/cbor-sync");
const DataItem_1 = require("../lib/DataItem");
const RegistryItem_1 = require("../RegistryItem");
const RegistryType_1 = require("../RegistryType");
var Keys;
(function (Keys) {
    Keys[Keys["requestId"] = 1] = "requestId";
    Keys[Keys["signature"] = 2] = "signature";
})(Keys || (Keys = {}));
class ETHSignature extends RegistryItem_1.RegistryItem {
    constructor(signature, requestId) {
        super();
        this.getRegistryType = () => RegistryType_1.RegistryTypes.ETH_SIGNATAURE;
        this.getRequestId = () => this.requestId;
        this.getSignature = () => this.signature;
        this.toDataItem = () => {
            const map = {};
            if (this.requestId) {
                map[Keys.requestId] = new DataItem_1.DataItem(this.requestId, RegistryType_1.RegistryTypes.UUID.getTag());
            }
            map[Keys.signature] = this.signature;
            return new DataItem_1.DataItem(map);
        };
        this.signature = signature;
        this.requestId = requestId;
    }
}
exports.ETHSignature = ETHSignature;
ETHSignature.fromDataItem = (dataItem) => {
    const map = dataItem.getData();
    const signature = map[Keys.signature];
    const requestId = map[Keys.requestId] ? map[Keys.requestId].getData() : undefined;
    return new ETHSignature(signature, requestId);
};
ETHSignature.fromCBOR = (_cborPayload) => {
    const dataItem = cbor_sync_1.decodeToDataItem(_cborPayload);
    return ETHSignature.fromDataItem(dataItem);
};
//# sourceMappingURL=EthSignature.js.map