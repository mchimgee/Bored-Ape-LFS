/// <reference types="node" />
import { EventEmitter } from 'events';
import { Transaction } from 'ethereumjs-tx';
declare type StoredKeyring = {
    xfp: string;
    xpub: string;
    hdPath: string;
    accounts: string[];
    currentAccount: number;
    page: number;
    perPage: number;
    paths: Record<string, number>;
};
declare type PagedAccount = {
    address: string;
    balance: any;
    index: number;
};
declare class AirGapedKeyring extends EventEmitter {
    static type: string;
    static getKeyring(): Promise<AirGapedKeyring>;
    static getEmptyKeyring(): AirGapedKeyring;
    private xfp;
    private xpub;
    private hdPath;
    private type;
    private accounts;
    private currentAccount;
    private page;
    private perPage;
    private paths;
    private hdk;
    private latestAccount;
    constructor(opts: StoredKeyring);
    readKeyring(): Promise<void>;
    private checkKeyring;
    serialize(): Promise<StoredKeyring>;
    deserialize(opts: StoredKeyring): void;
    setCurrentAccount(index: number): void;
    getCurrentAccount(): number;
    getCurrentAddress(): string;
    addAccounts(n?: number): Promise<string[]>;
    getFirstPage(): Promise<PagedAccount[]>;
    getNextPage(): Promise<PagedAccount[]>;
    getPreviousPage(): Promise<PagedAccount[]>;
    __getPage(increment: number): Promise<PagedAccount[]>;
    getAccounts(): string[];
    removeAccount(address: string): void;
    readSignature(signId: string): Promise<{
        r: Buffer;
        s: Buffer;
        v: Buffer;
    }>;
    private static serializeTx;
    signTransaction(address: string, tx: Transaction): Promise<Transaction>;
    signMessage(withAccount: string, data: string): Promise<string>;
    signPersonalMessage(withAccount: string, messageHex: string): Promise<string>;
    signTypedData(withAccount: string, typedData: any): Promise<Buffer>;
    _addressFromIndex(pb: string, i: number): string;
    _pathFromAddress(address: string): string;
}
export default AirGapedKeyring;
